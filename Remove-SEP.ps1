<#
    .SYNOPSIS
        Removes all copies of Symantec Endpoint Protection (SEP) that were installed via an MSI or an MSI wrapped
        in an EXE (such as the Setup.exe generated by the management console).

    .DESCRIPTION
        Removes all copies of Symantec Endpoint Protection (SEP) that were installed via an MSI or an MSI wrapped
        in an EXE (such as the Setup.exe generated by the management console). This includes removing the actual
        program, as well as any left over entries in Security Center.

        This script only works on the desktop edition of PowerShell for Microsoft Windows, and must be run with
        local administrative rights.

    .OUTPUTS
        System.Boolean

        Outputs $True if all operations were completed successfully, $False otherwise.

    .NOTES
        Author    : Dan Thompson
        Copyright : 2021 Case Western Reserve University
        Version   : 1.0.0
#>

#Requires -PSEdition Desktop
#Requires -Version 5.1
#Requires -RunAsAdministrator

[CmdletBinding(SupportsShouldProcess)]

param(
    # Skips uninstalling Symantec Endpoint Protection. Usually used if you have uninstalled SEP via other means
    # and just want to clean up the Security Center.
    [Alias('spu')]
    [switch]$SkipProductUninstall,

    # Skips removing entries left over in Security Center after an uninstall. These can prevent other AV products
    # from functioning properly.
    [Alias('sscc')]
    [switch]$SkipSecurityCenterCleanup,

    # Set this to not reboot if a reboot is needed.
    [Alias('sr')]
    [switch]$SkipReboot
)

$RebootNeeded = $False
$Success = $True
$ProductName = 'Symantec Endpoint Protection'

if ($SkipProductUninstall.IsPresent) {
    Write-Verbose -Message "Skipping uninstalling $ProductName per user preference."
} else {
    $UninstallPercentComplete = 0
    $UninstallProgressParams = @{
        'Activity' = "Uninstalling $ProductName ..."
        'CurrentOperation' = 'Looking for copies'
        'Status' = "$UninstallPercentComplete% Complete"
    }

    Write-Progress @UninstallProgressParams

    $Products = Get-WmiObject -Class 'Win32_Product' -Namespace 'root\cimv2' -Filter "Name='$ProductName'"
    $NumProducts = ($Products | Measure-Object).Count

    if ($Products) {
        Write-Verbose -Message "$NumProducts copies of $ProductName found."

        $Products | ForEach-Object {
            $ProductMessageSuffix = "copy with GUID $($_.IdentifyingNumber)."

            $UninstallProgressParams.CurrentOperation = "Uninstalling $ProductMessageSuffix"
            Write-Progress @UninstallProgressParams

            if ($PSCmdlet.ShouldProcess($_.IdentifyingNumber, 'Uninstall')) {
                if (0 -eq $_.Uninstall().ReturnValue) {
                    Write-Verbose -Message "Successfully uninstalled $ProductMessageSuffix."
                    $RebootNeeded = -not $SkipReboot.IsPresent
                } else {
                    Write-Error -Message "Failed to uninstall $ProductMessageSuffix."
                    $Success = $False
                }
            }

            $UninstallPercentComplete += (1 / $NumProducts) * 100
            $UninstallProgressParams.Status = "$($UninstallPercentComplete.ToString('#'))% Complete"
        }
    } else {
        Write-Warning -Message "No copies of $ProductName found."
    }
}

if ($SkipSecurityCenterCleanup.IsPresent) {
    Write-Verbose -Message 'Skipping Security Center cleanup per user preference.'
} else {
    $SCPercentComplete = 0
    $SCProgressParams = @{
        'Activity' = "Removing leftover entries for $ProductName ..."
        'CurrentOperation' = 'Looking for entries'
        'Status' = "$SCPercentComplete% Complete"
    }

    Write-Progress @SCProgressParams

    $SCGetWmiParams = @{
        'Class' = 'AntiVirusProduct'
        'Namespace' = 'root\SecurityCenter2'
        'Filter' = "displayName='$ProductName'"
    }

    $SCEntries = Get-WmiObject @SCGetWmiParams
    $NumSCEntries = ($SCEntries | Measure-Object).Count
    
    Write-Verbose -Message "$NumSCEntries leftover entries found in Security Center."
    
    if ($SCEntries) {
        $SCEntries | ForEach-Object {
            $SCMessageSuffix = "entry with identifying number $($_.IdentifyingNumber)."

            $SCProgressParams.CurrentOperation = "Removing $SCMessageSuffix"
            Write-Progress @SCProgressParams

            
            if ($PSCmdlet.ShouldProcess($_.IdentifyingNumber, 'Remove-WmiObject')) {
                $SCRemoveEntryJob = $_ | Remove-WmiObject -AsJob
                $SCRemoveEntryJob | Receive-Job -Wait -AutoRemoveJob | Out-Null

                if ('Completed' -eq $SCRemoveEntryJob.Status) {
                    Write-Verbose -Message "Successfully removed $SCMessageSuffix"
                } else {
                    Write-Error -Message "Failed to remove $SCMessageSuffix"
                    $Success = $False
                }
            }

            $SCPercentComplete += (1 / $NumSCEntries) * 100
            $SCProgressParams.Status = "$($SCPercentComplete.ToString('#'))% Complete"
        }
    }
}

$Success

if ($RebootNeeded) {
    if ($SkipReboot.IsPresent) {
        Write-Warning -Message 'Reboot required, but skipping per user preferences.'
    } else {
        Write-Verbose -Message 'Reboot required. Rebooting.'
        Restart-Computer
    }
} else {
    Write-Verbose -Message 'No reboot required.'
}
